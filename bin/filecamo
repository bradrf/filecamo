#!/usr/bin/env ruby

require_relative '../lib/filecamo'

BN = File.basename($0, '.rb')

cmd = ARGV.shift
if cmd == 'gen'
  if i = ARGV.index('-d')
    ARGV.delete_at(i)
    dst_path = ARGV.delete_at(i)
  end

  if ARGV.size  < 2
    bin, bm = BetterBytes::BINARY
    dec, dm = BetterBytes::DECIMAL
    
    $stderr.puts <<EOF

usage: #{BN} gen [-d <destination_path>] <minimum_size> <maximum_size> <count> <depth> [<percent_text>]

     The size MAY end with a unit label:
       * BINARY labels (#{bm} multiplier):  #{bin.join(', ')}
       * DECIMAL labels (#{dm} multiplier): #{dec.join(', ')}

     The count will determine the number of files to generate.

     The depth will determine the hierarchy of the files. The number of files will be randomly
     distributed among the tree.

     The percent text optional value indicates how many files should be text instead of binary.
     Default is none (i.e. all files have random binary content).

EOF
    exit 1
  end

  min, max, count, depth, percent_text = ARGV
  generator = Filecamo::Generator.new
  generator.generate(min, max, count, depth,
                     percent_text: percent_text, destination_path: dst_path) do |path, len|
    puts "#{BetterBytes.humanize(len, precision: 6.1)} => #{path}"
  end
  generator.wait do |txt_count, bin_count|
    $stdout.printf "\rWaiting for #{txt_count} txt and #{bin_count} bin jobs "\
                   "to complete..." + (' '*10)
    $stdout.flush
  end
  $stdout.puts
  generator.kill

elsif cmd == 'muck'
  if ARGV.size < 3
    $stderr.puts <<EOF

usage: #{BN} <percent_select> <percent_change> <path> [<path>...]

     The percent select should be a value from 1 to 100 indicating how likely a given file will be
     modified.

     The percent change should be a value from 1 to 100 indicating (roughly) how many lines should
     be added.

     Paths can be filenames or directories to recurse and will be descended breadth-first. Any file
     entry starting with '.' is skipped (ignored).

EOF
    exit 1
  end

  percent_select, percent_change, *paths = ARGV
  mucker = Filecamo::TextMucker.new(" #{BN}: ")
  mucker.muck(percent_select, percent_change, paths) do |fn, lang, line_nums|
    puts "Modified #{fn} (#{lang}): #{line_nums.join(',')}"
  end

else
  $stderr.puts <<EOF

usage: #{BN} { gen | muck } ...

EOF
  exit 1
end
